package com.aticatac.world.ai;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;

import com.aticatac.world.Level;
import com.aticatac.world.ai.utils.Translations;

import javafx.util.Pair;

public class AStar {
	/**
	 * The cost that should be used when travelling over tiles which are not owned
	 * by the player
	 */
	private static final double SLOW_COST = 1.5;

	/**
	 * The possible translations that can be applied to a point to move it in any
	 * directions adjacent to it
	 */
	private ArrayList<Pair<Integer, Integer>> translations = Translations.TRANSLATIONS_GRID;

	/**
	 * The starting point in the path
	 */
	private Point startPoint;

	/**
	 * The point to travel to from the starting point
	 */
	private Point finishPoint;

	/**
	 * The level that is currently being played in the game, which contains the map
	 * of points
	 */
	private Level level;

	/**
	 * A map of costs to a given point on the map
	 */
	private Map<Point, Double> cost;

	/**
	 * A map of the parent of a given point on the map
	 */
	private Map<Point, Point> parent;

	/**
	 * The unique identifier of the player
	 */
	private int identifier;

	// -----------
	// Constructor
	// -----------

	/**
	 * An A Star path-finding implementation to get from one point on the map to
	 * another given a player and the level they are playing
	 * 
	 * @param startPoint
	 *            The starting grid point on the map
	 * @param finishPoint
	 *            The finishing grid point on the map
	 * @param level
	 *            The level that is currently being played in the game, which
	 *            contains the map
	 * @param identifier
	 *            The unique identifier of the player
	 */
	public AStar(Point startPoint, Point finishPoint, Level level, int identifier) {
		this.startPoint = startPoint;
		this.finishPoint = finishPoint;
		this.level = level;
		this.identifier = identifier;
		this.cost = new HashMap<>();
		this.parent = new HashMap<>();
	}

	// -------
	// Methods
	// -------

	/**
	 * A method to calculate the heuristic which determines how close the current
	 * point being considered is to the finishing point
	 * 
	 * @param point
	 *            The current point being considered
	 * @return The distance between the two points as the addition of the absolute
	 *         difference between the x and y co-ordinates
	 */
	public int getH(Point point) {
		return Math.abs(point.x - finishPoint.x) + Math.abs(point.y - finishPoint.y);
	}

	/**
	 * Get the path that is generated by the algorithm
	 * 
	 * @return The path as a linked list of grid points that link the starting point
	 *         to the finishing point
	 */
	public LinkedList<Point> getPath() {
		LinkedList<Point> path = new LinkedList<>();
		cost.put(startPoint, 0.0);

		Queue<Point> opened = new PriorityQueue<>(11, new Comparator<Point>() {
			@Override
			public int compare(Point p1, Point p2) {
				if ((cost.get(p1) + getH(p1)) < (cost.get(p2) + getH(p2))) {
					return -1;
				} else if ((cost.get(p1) + getH(p1)) > (cost.get(p2) + getH(p2))) {
					return 1;
				}
				return 0;
			}
		});
		Point current = null;
		ArrayList<Point> visited = new ArrayList<Point>();
		opened.add(startPoint);

		while (!opened.isEmpty()) {
			current = opened.poll();
			visited.add(current);

			if (current.equals(finishPoint)) {
				break;
			}

			for (Point t : removeInvalid(getNeighbours(current))) {
				if (!visited.contains(t)) {
					if (level.getCoords(t.x, t.y) == identifier) {
						cost.put(t, cost.get(current) + 1);
					} else {
						// If the tile is covered in another player's colour, they will run over it
						// slower
						cost.put(t, cost.get(current) + SLOW_COST);
					}
					parent.put(t, current);
					opened.add(t);
				}
			}
		}

		assert (current.equals(finishPoint));
		Point parentPoint = null;

		try {
			while (!(parentPoint = parent.get(current)).equals(startPoint)) {
				path.add(current);
				current = parentPoint;
			}
		} catch (NullPointerException e) {
			// just ignore it, it will probably be fine
		}
		path.add(current);
		Collections.reverse(path);

		return path;
	}

	/**
	 * Remove any points from the current points being considered that are invalid
	 * (e.g. are walls or are off the grid)
	 * 
	 * @param neighbours
	 *            The list of points to be considered
	 * @return The list of points which are not invalid
	 */
	private ArrayList<Point> removeInvalid(ArrayList<Point> neighbours) {
		ArrayList<Point> validNeighbours = new ArrayList<>();
		int wall;
		for (Point p : neighbours) {
			wall = level.getCoords(p.x, p.y);
			// Remove those which are off the grid or collide with a wall
			if (wall != 1 && wall != -1) {
				validNeighbours.add(p);
			}
		}
		return validNeighbours;
	}

	/**
	 * Get the neighbours of the current point
	 * 
	 * @param p
	 *            The point to get neighbours of
	 * @return The points which are directly adjacent to the point p
	 */
	private ArrayList<Point> getNeighbours(Point p) {
		ArrayList<Point> neighbours = new ArrayList<>();
		Point current;
		int val;
		Pair<Integer, Integer> translation;
		for (int i = 0; i < 8; i++) {
			translation = translations.get(i);
			// Key is x translation, Value is y translation
			current = new Point(p.x + translation.getKey(), p.y + translation.getValue());
			val = level.getCoords(current.x, current.y);
			if (val != 1 && val != -1) {
				neighbours.add(current);
			}
		}
		return neighbours;
	}

}
